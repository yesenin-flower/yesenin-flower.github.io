
# Two Sum 输入有序数组
1. 分治
   第一个数字肯定要小于目标值target，那么我们每次用二分法来搜索target - numbers[i]即可
2. Trick
   两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止，

# 最小栈
1. 两个栈
   一个记录数值，一个记录当前最小值。

   ​
   当有新数push进来的时候，如果栈2为空或者这个数小于栈2顶上的值，就把这个数推入栈2。

   ​
   当pop的数正好等于最小值时，说明当前栈内的最小值变化了，要弹出这个最小值，记录的下一个最小值来到栈顶。

2. Trick
   一个整型变量min\_val来记录当前最小值，一同入栈，为节省空间，仅在当前最小值更改时才入栈。初始化为整型最大值。

   ​
   然后如果需要进栈的数字小于等于当前最小值min\_val，那么将min\_val和新进来的数压入栈，并且将min\_val更新为当前数字。

   ​
   在出栈操作时，先将栈顶元素移出栈，再判断该元素是否和min\_val相等，相等就把它下面记录的之前最小值赋给min\_val并弹出。


# 阶乘后的0

要求末尾有多少个零，则该数应为x*10k 的形式等于x*（2k *5k）\

也就是求该数分解质因子后有几个5就行