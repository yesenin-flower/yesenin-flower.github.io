# 最小栈
1. 两个栈
   一个记录数值，一个记录当前最小值。

   当有新数push进来的时候，如果栈2为空或者这个数小于栈2顶上的值，就把这个数推入栈2。

   当pop的数正好等于最小值时，说明当前栈内的最小值变化了，要弹出这个最小值，记录的下一个最小值来到栈顶。

2. Trick
   一个整型变量min\_val来记录当前最小值，一同入栈，为节省空间，仅在当前最小值更改时才入栈。初始化为整型最大值。

   然后如果需要进栈的数字小于等于当前最小值min\_val，那么将min\_val和新进来的数压入栈，并且将min\_val更新为当前数字。

   在出栈操作时，先将栈顶元素移出栈，再判断该元素是否和min\_val相等，相等就把它下面记录的之前最小值赋给min\_val并弹出。


# 阶乘后的0

要求末尾有多少个零，则该数应为x*10k 的形式等于x*（2k *5k）

也就是求该数分解质因子后有几个5就行

# 同构字符串

原字符串中的每个字符可由另外一个字符替代，可以被其本身替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。

根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若想等，将其值更新为i + 1

```cpp
bool isIsomorphic(string s, string t) {
    int m1[256] = {0}, m2[256] = {0}, n = s.size();
    for (int i = 0; i < n; ++i) {
        if (m1[s[i]] != m2[t[i]]) return false;
        m1[s[i]] = i + 1;
        m2[t[i]] = i + 1;
    }
    return true;
}
```