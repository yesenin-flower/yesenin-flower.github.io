
# Two Sum 输入有序数组
1. 分治
   第一个数字肯定要小于目标值target，那么我们每次用二分法来搜索target - numbers[i]即可
2. Trick
   两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止，

# 最小栈
1. 两个栈
   一个记录数值，一个记录当前最小值。

   当有新数push进来的时候，如果栈2为空或者这个数小于栈2顶上的值，就把这个数推入栈2。

   当pop的数正好等于最小值时，说明当前栈内的最小值变化了，要弹出这个最小值，记录的下一个最小值来到栈顶。

2. Trick
   一个整型变量min\_val来记录当前最小值，一同入栈，为节省空间，仅在当前最小值更改时才入栈。初始化为整型最大值。

   然后如果需要进栈的数字小于等于当前最小值min\_val，那么将min\_val和新进来的数压入栈，并且将min\_val更新为当前数字。

   在出栈操作时，先将栈顶元素移出栈，再判断该元素是否和min\_val相等，相等就把它下面记录的之前最小值赋给min\_val并弹出。


# 阶乘后的0

要求末尾有多少个零，则该数应为x*10k 的形式等于x*（2k *5k）

也就是求该数分解质因子后有几个5就行

#  旋转数组

前n-k个reverse，后k个reverse，再全局reverse

# 颠倒二进制位

```cpp
uint32_t reverseBits(uint32_t n) {
        uint32_t m=0;
        for(int i=0;i<32;i++){
            m<<=1;//m向左移1位；
            m = m|(n & 1);//m的末位设置为n的末位
            n>>=1;//n向右移1位
        }
        return m;
}
```

（1）&(与)–有0则0；无0则1； 
（2）|（或）–有1则1，无1则0； 
（3）^（亦或）–相同为0，不同为1； 
（4）>>右移（最右边的位被抛弃） 
正数，最左边添0；00001010>>3=00000001 
负数，最左边添1；10001010>>3=11110001 
（5）<<左移（最左边的位被抛弃）–最右边统一添0； 
（正数）00001010<<3=01010000 
（负数）10001010<<3=01010000 

# 同构字符串

原字符串中的每个字符可由另外一个字符替代，可以被其本身替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。

根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若想等，将其值更新为i + 1

# 计数质数

![](https://img-blog.csdn.net/20160201110938143)

# 二进制中1的个数

```cpp
int NumberOf1(int n)//有符号的n
{
    int count=0;
    int flag=1;
    while (flag)
    {
        if (n&flag)
        {
            count++;
        }
        flag=flag<<1;//左移一位
    }  
    return count;
}
```

# 快乐数

发现当在迭代循环判断是否为1的过程中时，若进入了这种无限循环，最终都会出现4，故一旦遇见4即可知道进入了无限循环，判断是非快乐数字，减少了时间复杂度