[TOC]

# OOD

Encapsulation: bundle a set of attributes that store the current state of the object with a set of methods.

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5iej698qzj21960bot9w.jpg" style="zoom:33%;" />

Inheritance: the child class inherit attributes and methods from the parent class. it can also add its own properties.

Polymorphism: the child class uses inherited methods to perform different tasks through overloading(重载) or overriding(重写)

Overloading: same method name but different parameters

Overriding: same method siginature in both parent class and child class

##Steps of OOD 

1. clarify requirement
2. define class(object)
3. define method, how data flow works
4. implementation

##Steps of system design

1. requirement  clarification (ask questions about what use case they want)
2. scale of the system - size

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5ic362j4xj20ry0jkjtw.jpg" style="zoom:33%;" />

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5ic40vfmxj20zg0ho40m.jpg" style="zoom:33%;" />

3. API interface(重要的method)

4. database data-model(primary key)

5. high-level design(draw picture: data flow)

   <img src="/Users/emma/Library/Application Support/typora-user-images/Screen Shot 2022-08-24 at 12.50.06 PM.png" alt="Screen Shot 2022-08-24 at 12.50.06 PM" style="zoom:33%;" />

   

   <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5id96db90j20qi0iutcp.jpg" style="zoom:33%;" />

   

   <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5id76azk4j212g0lkgom.jpg" style="zoom:33%;" />

6. detailed design(corner cases of user cases, cache, load balance, optimize)

7. Bottlenecks(single point of failure, replicas of the data if lost, monitoring, alart, autofix)

# 创建型模式

在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或builder模式 （更灵活但更加复杂）。 

Builder重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， Builder则允许你在获取产品前执行一些额外构造步骤。 

抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。

## 工厂模式(Factory pattern)

在工厂里创建具体产品,工厂定义一个创建对象的接口,client传入名字作为参数,在工厂里实例化具体的类.

**意图：**在工厂模式中，我们在创建对象时不会对client暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

**何时使用：**通过名字在不同条件下创建不同实例时。

**实现方法:** 

1. 让所有产品都遵循同一接口。 
2. 在factory类中添加一个空的**工厂方法**。 该方法的返回类型必须遵循通用的产品接口。 
3. 调用工厂方法来创建**产品构造函数**。 

**优点：** 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5cph0qsd6j217o0u0gq5.jpg" style="zoom:33%;" />

##抽象工厂模式(Abstract factory pattern)

一个产品有2维空间定义(比如风格,桌椅|win&mac, button&checkbox),每个空间都是一个factory,所有的factory继承一个abstract factory.client先决定第一个维度得到concrete factory,再掉不同参数得到第二个维度的产品

**意图：**围绕一个超级工厂创建其他工厂，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象.

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**实现:** 

1. 以不同的产品类型与产品变体为维度**绘制矩阵**。 
2. 为所有产品声明**抽象产品接口**。 
3. 然后让所有**具体产品类**实现这些接口。
4. 声明**抽象工厂接口**， 并且在接口中为**所有抽象产品提供一组构建方法**。 
5. 为每种产品变体实现一个**具体工厂类**。 
6. 在client中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定**具体工厂类**进行初始化。 
7. 调用工厂对象中相应**构建方法**来构造函数。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5cpjitp6tj21bh0u079q.jpg" style="zoom:33%;" />

## 建造者模式(Builder pattern)

**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

**何时使用：**constructor参数很多, order很难控制, 很多信息不能提取知道, 大部分optional as null

**实现方法:** 

1. 清晰地定义**通用步骤**， 确保它们可以制造所有形式的产品。 
2. 在基本**builder接口**中声明这些步骤。 为每个形式的产品创建具体生成器类， 并实现其构造步骤。 
3. 在**具体产品**中实现获取构造结果对象的方法.
4. 可以考虑**主管类**, 它可以使用同一builder对象来封装多种构造产品的方式。 
5. Client会同时创建builder和director。 构造开始前， 客户端必须将**生成器对象传递给主管对象**。 通常情况下， **客户端只需调用主管类构造函数一次即可**。 

**优点：** 1、建造者独立，易扩展。 2、便于控制细节风险。

**缺点：** 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5cpoplnsgj21aq0u0q8o.jpg" style="zoom:33%;" />

## 原型模式(Prototype pattern)

**意图：**用于创建重复的对象，同时又能保证性能。用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

**何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

**如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。

**优点：** 1、性能提高。 2、逃避构造函数的约束。

**缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。

**使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，**一般是和工厂方法模式一起出现**，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5ctnbvvd6j21bg0ssjv3.jpg" style="zoom:33%;" />

## 单例模式(Singleton pattern)

**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。判断系统是否已经有这个单例，如果有则返回，如果没有则创建。

**何时使用：**当您想控制实例数目，节省系统资源的时候。

**优点：**

- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
- 2、避免对资源的多重占用（比如写文件操作）。

**缺点：**没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5cpn1vgnpj20z80jc767.jpg" style="zoom:33%;" />

# 结构型模式

## 适配器模式(adapter pattern)

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

<img src="/Users/emma/Library/Application Support/typora-user-images/Screen Shot 2022-08-19 at 6.27.13 PM.png" alt="Screen Shot 2022-08-19 at 6.27.13 PM" style="zoom:33%;" />

<img src="/Users/emma/Library/Application Support/typora-user-images/Screen Shot 2022-08-19 at 6.27.46 PM.png" alt="Screen Shot 2022-08-19 at 6.27.46 PM" style="zoom:33%;" />

## 桥接模式(bridge pattern)

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5g7q97yk3j217j0u078l.jpg" style="zoom:33%;" />

## 组合模式(composite pattern)

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component

1. 确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。

2. 声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。

3. 创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。

4. 创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。

   实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。

5. 最后， 在容器中定义添加和删除子元素的方法。

   记住， 这些操作可在组件接口中声明。 这将会违反*接口隔离原则*， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5g7wpe7h2j21dm0pi0wj.jpg" style="zoom:33%;" />

## 装饰器模式(decorator pattern)

**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**如何解决：**将具体功能职责划分，同时继承装饰者模式。

**关键代码：** 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

1. 确保业务逻辑可用一个基本组件及多个额外可选层次表示。
2. 找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。
3. 创建一个具体组件类， 并定义其基础行为。
4. 创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。
5. 确保所有类实现组件接口。
6. 将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。
7. 客户端代码负责创建装饰并将其组合成客户端所需的形式。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5g82dplnlj21fl0u0dks.jpg" style="zoom:33%;" />

## 外观模式(facade pattern)

**意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。

**何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。

**如何解决：**客户端不与系统耦合，外观类与系统耦合。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h3aegmxvj21bo0s0dkk.jpg" style="zoom:33%;" />

## 享元模式(flyweight pattern)

**意图：**运用共享技术有效地支持大量细粒度的对象。

**主要解决：**在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

**何时使用：** 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h3xlce2pj214c0u0wjs.jpg" style="zoom:33%;" />

## 代理模式(proxy pattern)

**意图：**为其他对象提供一种代理以控制对这个对象的访问。

**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**何时使用：**想在访问一个类时做一些控制。

**如何解决：**增加中间层。

1. 如果没有现成的服务接口， 你就需要创建一个**接口来实现代理和服务对象的可交换性**。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。
2. 创建代理类， 其中必须包含一个**存储指向服务的引用的成员变量**。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。
3. 根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5ggiar6n8j21cg0lsq61.jpg" style="zoom:33%;" />

# 行为型模式

## 责任链模式(chain of responsibility pattern)

**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

**何时使用：**在处理消息的时候以过滤很多道。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h3tn48gzj21bo0n0q8l.jpg" style="zoom:33%;" />

## 命令模式 (command pattern)

**意图：**将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。

**主要解决：**在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

**何时使用：**在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

**如何解决：**通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h4bw9odlj21900u0n2b.jpg" style="zoom:33%;" />

## 迭代器模式(Iterator Pattern)

**意图：**提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。

**主要解决：**不同的方式来遍历整个整合对象。

**何时使用：**遍历一个聚合对象。

**如何解决：**把在元素之间游走的责任交给迭代器，而不是聚合对象。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h4trq7w3j214l0u0n1w.jpg" style="zoom:33%;" />

## 中介者模式(mediator pattern)

**意图：**用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

**主要解决：**对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。

**何时使用：**多个类相互耦合，形成了网状结构。

<img src="/Users/emma/Library/Application Support/typora-user-images/Screen Shot 2022-08-23 at 1.10.33 PM.png" alt="Screen Shot 2022-08-23 at 1.10.33 PM" style="zoom:33%;" />

## 备忘录模式 (memento pattern)

**意图：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

**主要解决：**所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。

**何时使用：**很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态。

**如何解决：**通过一个备忘录类专门存储对象状态。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h4iocp57j21aw0nwq7g.jpg" style="zoom:33%;" />

## 观察者模式(observer pattern)

**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

1. 仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。

2. 声明订阅者接口。 该接口至少应声明一个 `update`方法。

3. 声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。

4. 确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。

   但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。

5. 创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。

6. 在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h37e8xu0j21ee0u0dlh.jpg" style="zoom:33%;" />

## 状态模式 (State pattern)

**意图：**允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

**主要解决：**对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。

**何时使用：**代码中包含大量与对象状态有关的条件语句。

**如何解决：**将各种具体的状态类抽象出来。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h3dkjlf0j21cq0u0q8e.jpg" style="zoom:33%;" />

## 策略模式(strategy pattern)

**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

1. 从上下文类中找出**修改频率较高的算法** （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。
2. 声明该算法所有变体的通用**策略接口**。
3. 将算法逐一抽取到各自的类中， 它们都必须实现策略接口。
4. 在context中添加一个**成员变量**用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。
5. 客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5gevmidlzj21d60mm78e.jpg" style="zoom:33%;" />

## 模版模式(template pattern)

**意图：**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。

**何时使用：**有一些通用的方法。

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5h3vyoizbj20x00kyq4y.jpg" style="zoom:33%;" />

## 访问者模式(visitor pattern)

**意图：**主要将数据结构与数据操作分离。

**主要解决：**稳定的数据结构和易变的操作耦合问题。

**何时使用：**需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。

<img src="/Users/emma/Library/Application Support/typora-user-images/Screen Shot 2022-08-23 at 1.12.40 PM.png" alt="Screen Shot 2022-08-23 at 1.12.40 PM" style="zoom:33%;" />

# J2EE模式

## MVC 模式（MVC Pattern）

## 业务代表模式（Business Delegate Pattern）

## 组合实体模式（Composite Entity Pattern）

## 数据访问对象模式（Data Access Object Pattern）

## 前端控制器模式（Front Controller Pattern）

## 拦截过滤器模式（Intercepting Filter Pattern）

## 服务定位器模式（Service Locator Pattern）

## 传输对象模式（Transfer Object Pattern）